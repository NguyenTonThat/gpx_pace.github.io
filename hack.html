<!DOCTYPE html>
<html>

<head>
  <title>Change GPX Pace</title>
  <style>
    .form-group {
      display: flex;
      align-items: center;
    }

    .form-group label {
      /* margin-right: 20px; */
      width: 100px;
    }

    .divider {
      border: 1px solid #000;
      height: 2px;
      width: 100%;
      margin-bottom: 10px;
      margin-top: 5px;
    }

    #minPaceInput,
    #maxPaceInput {
      width: 50px;

    }

    .error-message {
      color: red;
      display: none;
      /* Initially hide the error message */

    }
  </style>
</head>

<body>
  <h1>Hack GPX</h1>

  <input type="file" id="gpxFileInput" onchange="handleFile()">
  <div style="padding: 4px;"></div>
  <label id="sliderLabel">Select distance (1km-10.0km):</label>

  <input type="range" id="distanceSlider" min="1" max="10" value="10" step="0.1" oninput="updateDistance()">
  <label id="selectedDistance">(10.0km)</label>
  <!-- <p id="selectedDistance">Selected Distance: 0 km</p> -->
  <div class="form-group">
    <label for="minPaceInput">MinPace: </label>
    <input type="number" id="minPaceInput" min="1" step="0.1" value="7">
    <label for="maxPaceInput" style="padding-left:10px;width: 80px;">MaxPace: </label>
    <input type="number" id="maxPaceInput" min="1" step="0.1" value="10">
  </div>
  <div style="padding: 4px;"></div>

  <div class="form-group">
    <label for="startTimeInput">Start Time: </label>
    <input type="datetime-local" id="startTimeInput" value="">
  </div>
  <div style="padding: 2px;"></div>
  <!-- Error message div -->
  <div class="error-message" id="errorMessage">Please choose a GPX file.</div>
  </div>
  <div class="divider"></div>
  <button onclick="changePace()">Change Pace</button>
  <button onclick="download()">Download</button>
  <script>



    function updateDistance() {
      const distanceSlider = document.getElementById('distanceSlider');
      const selectedDistanceElement = document.getElementById('selectedDistance');
      var selectedDistance = parseFloat(distanceSlider.value).toFixed(1);

      selectedDistanceElement.innerHTML = `(${selectedDistance}km)`;

      // Update the value of the slider itself
      distanceSlider.value = selectedDistance;
    }


    const LocalTimeOffset = 7 * 60 * 60 * 1000;//UTC+7 in milisecond 
    let parsedGPX = null
    hideErrorMessage();
    // Call the function to set the default start time when the page loads
    setDefaultStartTime();
    function handleFile() {
      var input = document.getElementById('gpxFileInput');

      // var statusElement = document.getElementById('status');

      // Check if a file is selected
      if (input.files.length > 0) {
        var file = input.files[0];
        var reader = new FileReader();
        // Set up the onload event for the reader
        reader.onload = function (e) {
          // File has been loaded successfully
          // displayMessage('Done');
          const gpxText = e.target.result;
          // Parse the GPX data into a DOM object
          const m_parsedGPX = parseGPX(gpxText);
          const trackPoints = m_parsedGPX.querySelectorAll('trkpt');
          let totalDistanceInKm = 0;
          let totalTimeInSecond = 0;
          let previousTrackPoint = null;
          for (let i = 0; i < trackPoints.length; i++) {
            const trackPoint = trackPoints[i];
            if (previousTrackPoint) {
              // Calculate the distance between the current and previous track points using the Haversine formula
              totalDistanceInKm += calculateDistance(previousTrackPoint, trackPoint);
              const previousTime = new Date(previousTrackPoint.querySelector('time').textContent);
              const currentTime = new Date(trackPoint.querySelector('time').textContent);
              totalTimeInSecond += (currentTime.getTime() - previousTime.getTime()) / 1000;
            }
            previousTrackPoint = trackPoint;

          };
          totalDistanceInKm = totalDistanceInKm.toFixed(1);
          if (totalDistanceInKm > 1) {
            const distanceSlider = document.getElementById('distanceSlider');
            const sliderLabel = document.getElementById('sliderLabel');
            const selectedDistanceElement = document.getElementById('selectedDistance');
            distanceSlider.max = totalDistanceInKm;
            distanceSlider.value = totalDistanceInKm;
            sliderLabel.textContent = `Select distance (1km-${totalDistanceInKm}km)`;
            selectedDistanceElement.innerHTML = `(${totalDistanceInKm}km)`;
          }

          displayMessage(`Distance:${(totalDistanceInKm)}km_______Time:${(totalTimeInSecond / 60).toFixed(1)}minutes`, 'blue');

        };

        // Read the file as text
        reader.readAsText(file);
      } else {
        // No file selected
        displayMessage('No file selected');
      }
    }
    // Function to display the error message
    function displayMessage(message, color = 'red') {
      const errorMessage = document.getElementById("errorMessage");
      errorMessage.textContent = message;
      errorMessage.style.color = color;
      errorMessage.style.display = "block";
    }
    // Function to hide the error message
    function hideErrorMessage() {
      const errorMessage = document.getElementById("errorMessage");
      errorMessage.style.display = "none";
    }
    // Function to set the default value of the start time input to the current time
    function setDefaultStartTime() {
      const startTimeInput = document.getElementById("startTimeInput");
      const now = new Date();
      const localTime = new Date(now.getTime() + LocalTimeOffset);
      const formattedTime = localTime.toISOString().slice(0, 16); // Remove seconds and milliseconds
      startTimeInput.value = formattedTime;
    }

    function parseGPX(gpxText) {
      // Implement GPX parsing logic (you may need a library)
      // This is a simplified example; use a GPX parsing library for accuracy
      // Return the parsed GPX data as a DOM object
      const parser = new DOMParser();
      const gpxDoc = parser.parseFromString(gpxText, "application/xml");
      return gpxDoc;
    }

    function download() {
      if (parsedGPX == null) {
        displayMessage("No Modified GPX file to download!", "blue");
        return;
      }
      // Serialize the modified GPX data back to XML format
      const serializer = new XMLSerializer();
      const modifiedGPXText = serializer.serializeToString(parsedGPX);

      //   Create a Blob and download the modified GPX file
      const blob = new Blob([modifiedGPXText], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);

      const downloadLink = document.createElement("a");
      downloadLink.href = url;
      downloadLink.download = "modified.gpx";
      downloadLink.click();

    }
    function changePace() {
      parsedGPX = null;
      const gpxFileInput = document.getElementById("gpxFileInput");
      const file = gpxFileInput.files[0];
      if (!file) {
        displayMessage("Please choose a GPX file.");
        return; // Exit the function early
      }
      // Hide the error message if a file is selected
      hideErrorMessage();
      //   const paceInput = document.getElementById("paceInput");
      const minPaceInput = document.getElementById("minPaceInput");
      const maxPaceInput = document.getElementById("maxPaceInput");
      const minPace = parseFloat(minPaceInput.value);
      const maxPace = parseFloat(maxPaceInput.value);

      const startTimeInput = document.getElementById("startTimeInput");
      const startTime = new Date(startTimeInput.value);

      if (file) {
        const reader = new FileReader();

        reader.onload = function (e) {
          const gpxText = e.target.result;

          // Parse the GPX data into a DOM object
          parsedGPX = parseGPX(gpxText);

          // Modify the pace to the user-defined value
          //   const newPace = Math.random() * (maxPace - minPace) + minPace;
          const { totalTimeInSecond, totalDistanceInKm } = modifyPace(parsedGPX, minPace, maxPace, startTime);
          displayMessage(
            "AvgPace:" + (totalTimeInSecond / 60 / totalDistanceInKm).toFixed(2) +
            "__________Time:" + (totalTimeInSecond / 60).toFixed(1) + "Min  " +
            " Distance:" + totalDistanceInKm.toFixed(1) + "km ",
            "blue");

        };

        reader.readAsText(file);
      }

    }


    // Function to generate a second random pace based on the first one
    function generateSecondRandomPace(maxPaceInSeconds, minPaceInSeconds, firstRandomPace = 0) {
      if (firstRandomPace == 0) return Math.random() * (maxPaceInSeconds - minPaceInSeconds) + minPaceInSeconds;
      const randomFactor = (Math.random() * 6) - 3; // Random value in the range [-3, 3]
      const randomizedPace = Math.round(firstRandomPace + randomFactor);

      return Math.max(minPaceInSeconds, Math.min(maxPaceInSeconds, randomizedPace));
    }
    function modifyPace(parsedGPX, minPace, maxPace, startTime) {
      // Calculate the time interval for the new pace (in seconds per kilometer)
      const maxPaceInSeconds = minPace * 60;
      const minPaceInSeconds = maxPace * 60;
      let totalTimeInSecond = 0;
      let totalDistanceInKm = 0;
      const distanceSlider = document.getElementById('distanceSlider');
      const maxDistanceVal = parseFloat(distanceSlider.value).toFixed(1) - 0.01;
      //   const paceInSeconds = newPace * 60;
      const gpxElement = parsedGPX.querySelector('gpx');
      gpxElement.setAttribute('creator', 'iPhone12');
      const metadata = parsedGPX.querySelectorAll('metadata');
      if (metadata) {
        metadata[0].querySelector('time').textContent = startTime.toISOString();
      }
      // Retrieve all track points in the GPX file
      const trackPoints = parsedGPX.querySelectorAll('trkpt');
      let previousTrackPoint = null;
      for (let i = 0; i < trackPoints.length; i++) {
        const trackPoint = trackPoints[i];
        let paceInSeconds = 0;
        if (previousTrackPoint) {
          paceInSeconds = generateSecondRandomPace(maxPaceInSeconds, minPaceInSeconds, paceInSeconds);

          // Calculate the distance between the current and previous track points using the Haversine formula
          const distanceKilometers = calculateDistance(previousTrackPoint, trackPoint);

          // Calculate the time interval based on the pace and distance
          const timeIntervalSeconds = paceInSeconds * distanceKilometers;

          // Update the time of the current track point
          //   const currentTime = new Date(startTime);
          const currentTime = new Date(previousTrackPoint.querySelector('time').textContent);
          currentTime.setTime(currentTime.getTime() + timeIntervalSeconds * 1e3)
          trackPoint.querySelector('time').textContent = currentTime.toISOString();
          totalTimeInSecond += timeIntervalSeconds;
          totalDistanceInKm += distanceKilometers;
          if (totalDistanceInKm > maxDistanceVal) {
            // Remove elements from the specified index to the end
            for (let rmIdx = i; rmIdx < trackPoints.length; rmIdx++) {
              let trackPoint = trackPoints[rmIdx];
              trackPoint.parentNode.removeChild(trackPoint);
            }
            break;
          }
        }
        else {
          trackPoint.querySelector('time').textContent = startTime.toISOString();
        }


        previousTrackPoint = trackPoint;
      }
      return { totalTimeInSecond: totalTimeInSecond, totalDistanceInKm: totalDistanceInKm };
    }

    function calculateDistance(point1, point2) {
      const lat1 = parseFloat(point1.getAttribute('lat'));
      const lon1 = parseFloat(point1.getAttribute('lon'));
      const lat2 = parseFloat(point2.getAttribute('lat'));
      const lon2 = parseFloat(point2.getAttribute('lon'));

      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * (Math.PI / 180);
      const dLon = (lon2 - lon1) * (Math.PI / 180);

      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;

      return distance;
    }
  </script>
</body>

</html>
